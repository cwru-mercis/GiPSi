// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// .\be\be_codegen.cpp:703

#ifndef _TAO_IDL_HAPTICSS_CPP_
#define _TAO_IDL_HAPTICSS_CPP_


#include "HapticsS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Fixed_Size_SArgument_T.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Basic_Arguments.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "HapticsS.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// .\be\be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:868

#if !defined (_CORBAHAPTICCONFIGURATION__SARG_TRAITS_)
#define _CORBAHAPTICCONFIGURATION__SARG_TRAITS_
  
  template<>
  class SArg_Traits<CORBAHapticConfiguration>
    : public
        Fixed_Size_SArg_Traits_T<
            CORBAHapticConfiguration,
            TAO::Any_Insert_Policy_Noop <CORBAHapticConfiguration>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:868

#if !defined (_CORBAGIPSILOWORDERLINEARHAPTICMODEL__SARG_TRAITS_)
#define _CORBAGIPSILOWORDERLINEARHAPTICMODEL__SARG_TRAITS_
  
  template<>
  class SArg_Traits<CORBAGiPSiLowOrderLinearHapticModel>
    : public
        Var_Size_SArg_Traits_T<
            CORBAGiPSiLowOrderLinearHapticModel,
            TAO::Any_Insert_Policy_Noop <CORBAGiPSiLowOrderLinearHapticModel>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// .\be\be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:868

#if !defined (_CORBAHAPTICCONFIGURATION__ARG_TRAITS_)
#define _CORBAHAPTICCONFIGURATION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<CORBAHapticConfiguration>
    : public
        Fixed_Size_Arg_Traits_T<
            CORBAHapticConfiguration,
            TAO::Any_Insert_Policy_Noop <CORBAHapticConfiguration>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:868

#if !defined (_CORBAGIPSILOWORDERLINEARHAPTICMODEL__ARG_TRAITS_)
#define _CORBAGIPSILOWORDERLINEARHAPTICMODEL__ARG_TRAITS_
  
  template<>
  class Arg_Traits<CORBAGiPSiLowOrderLinearHapticModel>
    : public
        Var_Size_Arg_Traits_T<
            CORBAGiPSiLowOrderLinearHapticModel,
            TAO::Any_Insert_Policy_Noop <CORBAGiPSiLowOrderLinearHapticModel>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// .\be\be_interface.cpp:1549

class TAO_CORBAHapticInterface_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBAHapticInterface_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBAHapticInterface_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32,  0, 32,  0,
     32, 32, 32,  0, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,  0,  0, 32, 32,
     32,  0, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32,  0, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 10, 10, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  0,
     32, 32, 32,  0, 32, 32, 32, 32, 32, 32,
     32, 32,  0, 32, 10, 10, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 32, 32, 32,  0, 32,
      0, 32, 32, 32,  0, 32, 10, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBAHapticInterface_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 31,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 27,
      DUPLICATES = 0,
      WORDLIST_SIZE = 20
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBAHapticInterface::_is_a_skel, 0},
      {"Enable", &POA_CORBAHapticInterface::Enable_skel, 0},
      {"Disable", &POA_CORBAHapticInterface::Disable_skel, 0},
      {"",0,0},
      {"IsEnabled", &POA_CORBAHapticInterface::IsEnabled_skel, 0},
      {"_interface", &POA_CORBAHapticInterface::_interface_skel, 0},
      {"",0,0},{"",0,0},
      {"IsInitialized", &POA_CORBAHapticInterface::IsInitialized_skel, 0},
      {"_repository_id", &POA_CORBAHapticInterface::_repository_id_skel, 0},
      {"",0,0},
      {"ReportUpdateRate", &POA_CORBAHapticInterface::ReportUpdateRate_skel, 0},
      {"ReadConfiguration", &POA_CORBAHapticInterface::ReadConfiguration_skel, 0},
      {"ReportSamplingTime", &POA_CORBAHapticInterface::ReportSamplingTime_skel, 0},
      {"Terminate", &POA_CORBAHapticInterface::Terminate_skel, 0},
      {"_component", &POA_CORBAHapticInterface::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBAHapticInterface::_non_existent_skel, 0},
      {"UseHapticModel", &POA_CORBAHapticInterface::UseHapticModel_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"ReturnHapticInterfaceIdentifier", &POA_CORBAHapticInterface::ReturnHapticInterfaceIdentifier_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBAHapticInterface_Perfect_Hash_OpTable tao_CORBAHapticInterface_optable;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
_TAO_CORBAHapticInterface_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
_TAO_CORBAHapticInterface_Proxy_Broker_Factory_Initializer (size_t)
{
  _TAO_CORBAHapticInterface_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBAHapticInterface_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
_TAO_CORBAHapticInterface_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBAHapticInterface_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (_TAO_CORBAHapticInterface_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:103

POA_CORBAHapticInterface::POA_CORBAHapticInterface (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBAHapticInterface_optable;
}

POA_CORBAHapticInterface::POA_CORBAHapticInterface (const POA_CORBAHapticInterface& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CORBAHapticInterface::~POA_CORBAHapticInterface (void)
{
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class Enable_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline Enable_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->Enable ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::Enable_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  Enable_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class Disable_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline Disable_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->Disable ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::Disable_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  Disable_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class Terminate_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline Terminate_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->Terminate ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::Terminate_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  Terminate_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class ReturnHapticInterfaceIdentifier_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline ReturnHapticInterfaceIdentifier_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->ReturnHapticInterfaceIdentifier ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::ReturnHapticInterfaceIdentifier_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  ReturnHapticInterfaceIdentifier_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class IsInitialized_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline IsInitialized_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->IsInitialized ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::IsInitialized_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  IsInitialized_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class IsEnabled_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline IsEnabled_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->IsEnabled ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::IsEnabled_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  IsEnabled_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class ReportUpdateRate_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline ReportUpdateRate_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Double>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Double> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->ReportUpdateRate ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::ReportUpdateRate_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Double>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  ReportUpdateRate_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class ReportSamplingTime_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline ReportSamplingTime_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Double>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Double> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->ReportSamplingTime ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::ReportSamplingTime_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Double>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  ReportSamplingTime_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class ReadConfiguration_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline ReadConfiguration_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBAHapticConfiguration>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBAHapticConfiguration> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->ReadConfiguration ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::ReadConfiguration_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBAHapticConfiguration>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  ReadConfiguration_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class UseHapticModel_CORBAHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline UseHapticModel_CORBAHapticInterface (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBAGiPSiLowOrderLinearHapticModel>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBAGiPSiLowOrderLinearHapticModel> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_->UseHapticModel (
        arg_1);
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticInterface::UseHapticModel_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  TAO::SArg_Traits< ::CORBAGiPSiLowOrderLinearHapticModel>::in_arg_val _tao_model;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_model
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);

  UseHapticModel_CORBAHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:169



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _is_a_CORBAHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _is_a_CORBAHapticInterface_Upcall_Command (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_-> _is_a (
        arg_1);
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticInterface::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);
  
  _is_a_CORBAHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _non_existent_CORBAHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _non_existent_CORBAHapticInterface_Upcall_Command (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _non_existent ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticInterface::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);
  
  _non_existent_CORBAHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _repository_id_CORBAHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _repository_id_CORBAHapticInterface_Upcall_Command (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _repository_id ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticInterface::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);
  
  _repository_id_CORBAHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:508

void POA_CORBAHapticInterface::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _get_component_CORBAHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _get_component_CORBAHapticInterface_Upcall_Command (
    POA_CORBAHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _get_component ();
  }

private:
  POA_CORBAHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticInterface::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticInterface * const impl =
    static_cast<POA_CORBAHapticInterface *> (servant);
  
  _get_component_CORBAHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBAHapticInterface::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAHapticInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBAHapticInterface::_interface_repository_id (void) const
{
  return "IDL:CORBAHapticInterface:1.0";
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:902

void POA_CORBAHapticInterface::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:852

CORBAHapticInterface *
POA_CORBAHapticInterface::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBAHapticInterface STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_CORBAHapticInterface_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1549

class TAO_CORBAPhantomHapticInterface_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBAPhantomHapticInterface_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBAPhantomHapticInterface_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32,  0, 32,  0,
     32, 32, 32,  0, 32, 32, 32, 32, 32, 32,
     32, 32,  0, 10, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,  0,  0, 32, 32,
     32,  0, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32,  0, 32, 32,
     32, 32, 32, 32, 32, 32, 10, 15, 15, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  0,
     32, 32, 32,  0, 32, 32, 32, 32, 32, 32,
     32, 32,  0, 10, 15, 15, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 32, 32, 32,  0, 32,
      0, 32, 32, 32,  0,  0, 10, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBAPhantomHapticInterface_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 31,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 27,
      DUPLICATES = 0,
      WORDLIST_SIZE = 23
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBAPhantomHapticInterface::_is_a_skel, 0},
      {"Enable", &POA_CORBAPhantomHapticInterface::Enable_skel, 0},
      {"Disable", &POA_CORBAPhantomHapticInterface::Disable_skel, 0},
      {"",0,0},
      {"IsEnabled", &POA_CORBAPhantomHapticInterface::IsEnabled_skel, 0},
      {"_interface", &POA_CORBAPhantomHapticInterface::_interface_skel, 0},
      {"switchModel", &POA_CORBAPhantomHapticInterface::switchModel_skel, 0},
      {"ReturnHandle", &POA_CORBAPhantomHapticInterface::ReturnHandle_skel, 0},
      {"IsInitialized", &POA_CORBAPhantomHapticInterface::IsInitialized_skel, 0},
      {"_repository_id", &POA_CORBAPhantomHapticInterface::_repository_id_skel, 0},
      {"",0,0},
      {"ReportUpdateRate", &POA_CORBAPhantomHapticInterface::ReportUpdateRate_skel, 0},
      {"ReadConfiguration", &POA_CORBAPhantomHapticInterface::ReadConfiguration_skel, 0},
      {"ReportSamplingTime", &POA_CORBAPhantomHapticInterface::ReportSamplingTime_skel, 0},
      {"SetHandle", &POA_CORBAPhantomHapticInterface::SetHandle_skel, 0},
      {"_component", &POA_CORBAPhantomHapticInterface::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBAPhantomHapticInterface::_non_existent_skel, 0},
      {"Terminate", &POA_CORBAPhantomHapticInterface::Terminate_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"UseHapticModel", &POA_CORBAPhantomHapticInterface::UseHapticModel_skel, 0},
      {"",0,0},
      {"ReturnHapticInterfaceIdentifier", &POA_CORBAPhantomHapticInterface::ReturnHapticInterfaceIdentifier_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBAPhantomHapticInterface_Perfect_Hash_OpTable tao_CORBAPhantomHapticInterface_optable;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
_TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
_TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_Initializer (size_t)
{
  _TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
_TAO_CORBAPhantomHapticInterface_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (_TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:103

POA_CORBAPhantomHapticInterface::POA_CORBAPhantomHapticInterface (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBAPhantomHapticInterface_optable;
}

POA_CORBAPhantomHapticInterface::POA_CORBAPhantomHapticInterface (const POA_CORBAPhantomHapticInterface& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBAHapticInterface (rhs)
{
}

POA_CORBAPhantomHapticInterface::~POA_CORBAPhantomHapticInterface (void)
{
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class SetHandle_CORBAPhantomHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline SetHandle_CORBAPhantomHapticInterface (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBA::Short>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_->SetHandle (
        arg_1);
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAPhantomHapticInterface::SetHandle_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Short>::in_arg_val _tao_handler;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_handler
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);

  SetHandle_CORBAPhantomHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class switchModel_CORBAPhantomHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline switchModel_CORBAPhantomHapticInterface (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->switchModel ();
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAPhantomHapticInterface::switchModel_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);

  switchModel_CORBAPhantomHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class ReturnHandle_CORBAPhantomHapticInterface
  : public TAO::Upcall_Command
{
public:
  inline ReturnHandle_CORBAPhantomHapticInterface (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->ReturnHandle ();
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAPhantomHapticInterface::ReturnHandle_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);

  ReturnHandle_CORBAPhantomHapticInterface command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:169



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _is_a_CORBAPhantomHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _is_a_CORBAPhantomHapticInterface_Upcall_Command (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_-> _is_a (
        arg_1);
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAPhantomHapticInterface::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);
  
  _is_a_CORBAPhantomHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _non_existent_CORBAPhantomHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _non_existent_CORBAPhantomHapticInterface_Upcall_Command (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _non_existent ();
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAPhantomHapticInterface::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);
  
  _non_existent_CORBAPhantomHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _repository_id_CORBAPhantomHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _repository_id_CORBAPhantomHapticInterface_Upcall_Command (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _repository_id ();
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAPhantomHapticInterface::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);
  
  _repository_id_CORBAPhantomHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:508

void POA_CORBAPhantomHapticInterface::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _get_component_CORBAPhantomHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _get_component_CORBAPhantomHapticInterface_Upcall_Command (
    POA_CORBAPhantomHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _get_component ();
  }

private:
  POA_CORBAPhantomHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAPhantomHapticInterface::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAPhantomHapticInterface * const impl =
    static_cast<POA_CORBAPhantomHapticInterface *> (servant);
  
  _get_component_CORBAPhantomHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBAPhantomHapticInterface::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAHapticInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAPhantomHapticInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBAPhantomHapticInterface::_interface_repository_id (void) const
{
  return "IDL:CORBAPhantomHapticInterface:1.0";
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:902

void POA_CORBAPhantomHapticInterface::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:852

CORBAPhantomHapticInterface *
POA_CORBAPhantomHapticInterface::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBAPhantomHapticInterface STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1549

class TAO_CORBAMouseHapticInterface_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBAMouseHapticInterface_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBAMouseHapticInterface_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32,  0, 32,  0,
     32, 32, 32,  0, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,  0,  0, 32, 32,
     32,  0, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32,  0, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 10, 10, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  0,
     32, 32, 32,  0, 32, 32, 32, 32, 32, 32,
     32, 32,  0, 32, 10, 10, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 32, 32, 32,  0, 32,
      0, 32, 32, 32,  0, 32, 10, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBAMouseHapticInterface_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 31,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 27,
      DUPLICATES = 0,
      WORDLIST_SIZE = 20
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBAMouseHapticInterface::_is_a_skel, 0},
      {"Enable", &POA_CORBAMouseHapticInterface::Enable_skel, 0},
      {"Disable", &POA_CORBAMouseHapticInterface::Disable_skel, 0},
      {"",0,0},
      {"IsEnabled", &POA_CORBAMouseHapticInterface::IsEnabled_skel, 0},
      {"_interface", &POA_CORBAMouseHapticInterface::_interface_skel, 0},
      {"",0,0},{"",0,0},
      {"IsInitialized", &POA_CORBAMouseHapticInterface::IsInitialized_skel, 0},
      {"_repository_id", &POA_CORBAMouseHapticInterface::_repository_id_skel, 0},
      {"",0,0},
      {"ReportUpdateRate", &POA_CORBAMouseHapticInterface::ReportUpdateRate_skel, 0},
      {"ReadConfiguration", &POA_CORBAMouseHapticInterface::ReadConfiguration_skel, 0},
      {"ReportSamplingTime", &POA_CORBAMouseHapticInterface::ReportSamplingTime_skel, 0},
      {"Terminate", &POA_CORBAMouseHapticInterface::Terminate_skel, 0},
      {"_component", &POA_CORBAMouseHapticInterface::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBAMouseHapticInterface::_non_existent_skel, 0},
      {"UseHapticModel", &POA_CORBAMouseHapticInterface::UseHapticModel_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"ReturnHapticInterfaceIdentifier", &POA_CORBAMouseHapticInterface::ReturnHapticInterfaceIdentifier_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBAMouseHapticInterface_Perfect_Hash_OpTable tao_CORBAMouseHapticInterface_optable;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
_TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
_TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_Initializer (size_t)
{
  _TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
_TAO_CORBAMouseHapticInterface_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (_TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:103

POA_CORBAMouseHapticInterface::POA_CORBAMouseHapticInterface (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBAMouseHapticInterface_optable;
}

POA_CORBAMouseHapticInterface::POA_CORBAMouseHapticInterface (const POA_CORBAMouseHapticInterface& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBAHapticInterface (rhs)
{
}

POA_CORBAMouseHapticInterface::~POA_CORBAMouseHapticInterface (void)
{
}


// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:169



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _is_a_CORBAMouseHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _is_a_CORBAMouseHapticInterface_Upcall_Command (
    POA_CORBAMouseHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_-> _is_a (
        arg_1);
  }

private:
  POA_CORBAMouseHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAMouseHapticInterface::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAMouseHapticInterface * const impl =
    static_cast<POA_CORBAMouseHapticInterface *> (servant);
  
  _is_a_CORBAMouseHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _non_existent_CORBAMouseHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _non_existent_CORBAMouseHapticInterface_Upcall_Command (
    POA_CORBAMouseHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _non_existent ();
  }

private:
  POA_CORBAMouseHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAMouseHapticInterface::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAMouseHapticInterface * const impl =
    static_cast<POA_CORBAMouseHapticInterface *> (servant);
  
  _non_existent_CORBAMouseHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _repository_id_CORBAMouseHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _repository_id_CORBAMouseHapticInterface_Upcall_Command (
    POA_CORBAMouseHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _repository_id ();
  }

private:
  POA_CORBAMouseHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAMouseHapticInterface::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAMouseHapticInterface * const impl =
    static_cast<POA_CORBAMouseHapticInterface *> (servant);
  
  _repository_id_CORBAMouseHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:508

void POA_CORBAMouseHapticInterface::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CORBAMouseHapticInterface * const impl =
    static_cast<POA_CORBAMouseHapticInterface *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _get_component_CORBAMouseHapticInterface_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _get_component_CORBAMouseHapticInterface_Upcall_Command (
    POA_CORBAMouseHapticInterface * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _get_component ();
  }

private:
  POA_CORBAMouseHapticInterface * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAMouseHapticInterface::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAMouseHapticInterface * const impl =
    static_cast<POA_CORBAMouseHapticInterface *> (servant);
  
  _get_component_CORBAMouseHapticInterface_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBAMouseHapticInterface::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAHapticInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAMouseHapticInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBAMouseHapticInterface::_interface_repository_id (void) const
{
  return "IDL:CORBAMouseHapticInterface:1.0";
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:902

void POA_CORBAMouseHapticInterface::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:852

CORBAMouseHapticInterface *
POA_CORBAMouseHapticInterface::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBAMouseHapticInterface STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1549

class TAO_CORBAHapticsManager_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBAHapticsManager_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBAHapticsManager_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28,  0,  5, 28,  0, 28,  0, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28,  0,  0, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28,  0, 28,  5,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,  0, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,
#else
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28,  5, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28,  0, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0, 28,  0, 28, 28,
      0,  5, 28,  0, 28,  0, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0,  0, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBAHapticsManager_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 27,
      HASH_VALUE_RANGE = 23,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBAHapticsManager::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CORBAHapticsManager::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBAHapticsManager::_non_existent_skel, 0},
      {"_repository_id", &POA_CORBAHapticsManager::_repository_id_skel, 0},
      {"_interface", &POA_CORBAHapticsManager::_interface_skel, 0},
      {"EndHapticsThread", &POA_CORBAHapticsManager::EndHapticsThread_skel, 0},
      {"",0,0},
      {"StartHapticsThread", &POA_CORBAHapticsManager::StartHapticsThread_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"isHapticsThreadRunning", &POA_CORBAHapticsManager::isHapticsThreadRunning_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"GetNumHapticInterfaces", &POA_CORBAHapticsManager::GetNumHapticInterfaces_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBAHapticsManager_Perfect_Hash_OpTable tao_CORBAHapticsManager_optable;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
_TAO_CORBAHapticsManager_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
_TAO_CORBAHapticsManager_Proxy_Broker_Factory_Initializer (size_t)
{
  _TAO_CORBAHapticsManager_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBAHapticsManager_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
_TAO_CORBAHapticsManager_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBAHapticsManager_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (_TAO_CORBAHapticsManager_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:103

POA_CORBAHapticsManager::POA_CORBAHapticsManager (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBAHapticsManager_optable;
}

POA_CORBAHapticsManager::POA_CORBAHapticsManager (const POA_CORBAHapticsManager& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CORBAHapticsManager::~POA_CORBAHapticsManager (void)
{
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class StartHapticsThread_CORBAHapticsManager
  : public TAO::Upcall_Command
{
public:
  inline StartHapticsThread_CORBAHapticsManager (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->StartHapticsThread ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticsManager::StartHapticsThread_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);

  StartHapticsThread_CORBAHapticsManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class EndHapticsThread_CORBAHapticsManager
  : public TAO::Upcall_Command
{
public:
  inline EndHapticsThread_CORBAHapticsManager (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->EndHapticsThread ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticsManager::EndHapticsThread_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);

  EndHapticsThread_CORBAHapticsManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class isHapticsThreadRunning_CORBAHapticsManager
  : public TAO::Upcall_Command
{
public:
  inline isHapticsThreadRunning_CORBAHapticsManager (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->isHapticsThreadRunning ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticsManager::isHapticsThreadRunning_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);

  isHapticsThreadRunning_CORBAHapticsManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class GetNumHapticInterfaces_CORBAHapticsManager
  : public TAO::Upcall_Command
{
public:
  inline GetNumHapticInterfaces_CORBAHapticsManager (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Short>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Short> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_->GetNumHapticInterfaces ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBAHapticsManager::GetNumHapticInterfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Short>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);

  GetNumHapticInterfaces_CORBAHapticsManager command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:169



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _is_a_CORBAHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _is_a_CORBAHapticsManager_Upcall_Command (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_-> _is_a (
        arg_1);
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticsManager::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);
  
  _is_a_CORBAHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _non_existent_CORBAHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _non_existent_CORBAHapticsManager_Upcall_Command (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _non_existent ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticsManager::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);
  
  _non_existent_CORBAHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _repository_id_CORBAHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _repository_id_CORBAHapticsManager_Upcall_Command (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _repository_id ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticsManager::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);
  
  _repository_id_CORBAHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:508

void POA_CORBAHapticsManager::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _get_component_CORBAHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _get_component_CORBAHapticsManager_Upcall_Command (
    POA_CORBAHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _get_component ();
  }

private:
  POA_CORBAHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAHapticsManager::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAHapticsManager * const impl =
    static_cast<POA_CORBAHapticsManager *> (servant);
  
  _get_component_CORBAHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBAHapticsManager::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAHapticsManager:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBAHapticsManager::_interface_repository_id (void) const
{
  return "IDL:CORBAHapticsManager:1.0";
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:902

void POA_CORBAHapticsManager::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:852

CORBAHapticsManager *
POA_CORBAHapticsManager::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBAHapticsManager STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_CORBAHapticsManager_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// .\be\be_interface.cpp:1549

class TAO_CORBAOpenHapticsManager_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBAOpenHapticsManager_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBAOpenHapticsManager_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28, 28,  0,  5, 28,  0, 28,  0, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28,  0,  0, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28,  0, 28,  5,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,  0, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28,
#else
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28, 28,  0,
     28,  5, 28, 28, 28, 28, 28, 28, 28, 28,
     28, 28, 28,  0, 28, 28, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0, 28,  0, 28, 28,
      0,  5, 28,  0, 28,  0, 28, 28, 28, 28,
     28, 28, 28, 28, 28,  0,  0, 28, 28, 28,
     28, 28, 28, 28, 28, 28, 28, 28,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBAOpenHapticsManager_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 27,
      HASH_VALUE_RANGE = 23,
      DUPLICATES = 0,
      WORDLIST_SIZE = 14
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBAOpenHapticsManager::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CORBAOpenHapticsManager::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBAOpenHapticsManager::_non_existent_skel, 0},
      {"_repository_id", &POA_CORBAOpenHapticsManager::_repository_id_skel, 0},
      {"_interface", &POA_CORBAOpenHapticsManager::_interface_skel, 0},
      {"EndHapticsThread", &POA_CORBAOpenHapticsManager::EndHapticsThread_skel, 0},
      {"",0,0},
      {"StartHapticsThread", &POA_CORBAOpenHapticsManager::StartHapticsThread_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},
      {"isHapticsThreadRunning", &POA_CORBAOpenHapticsManager::isHapticsThreadRunning_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"GetNumHapticInterfaces", &POA_CORBAOpenHapticsManager::GetNumHapticInterfaces_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBAOpenHapticsManager_Perfect_Hash_OpTable tao_CORBAOpenHapticsManager_optable;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
_TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
_TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_Initializer (size_t)
{
  _TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_function_pointer = 
    _TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
_TAO_CORBAOpenHapticsManager_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (_TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:103

POA_CORBAOpenHapticsManager::POA_CORBAOpenHapticsManager (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBAOpenHapticsManager_optable;
}

POA_CORBAOpenHapticsManager::POA_CORBAOpenHapticsManager (const POA_CORBAOpenHapticsManager& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBAHapticsManager (rhs)
{
}

POA_CORBAOpenHapticsManager::~POA_CORBAOpenHapticsManager (void)
{
}


// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:169



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _is_a_CORBAOpenHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _is_a_CORBAOpenHapticsManager_Upcall_Command (
    POA_CORBAOpenHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
      TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_,
        1);
      
    retval =
      this->servant_-> _is_a (
        arg_1);
  }

private:
  POA_CORBAOpenHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAOpenHapticsManager::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBAOpenHapticsManager * const impl =
    static_cast<POA_CORBAOpenHapticsManager *> (servant);
  
  _is_a_CORBAOpenHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _non_existent_CORBAOpenHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _non_existent_CORBAOpenHapticsManager_Upcall_Command (
    POA_CORBAOpenHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _non_existent ();
  }

private:
  POA_CORBAOpenHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAOpenHapticsManager::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAOpenHapticsManager * const impl =
    static_cast<POA_CORBAOpenHapticsManager *> (servant);
  
  _non_existent_CORBAOpenHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _repository_id_CORBAOpenHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _repository_id_CORBAOpenHapticsManager_Upcall_Command (
    POA_CORBAOpenHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _repository_id ();
  }

private:
  POA_CORBAOpenHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAOpenHapticsManager::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAOpenHapticsManager * const impl =
    static_cast<POA_CORBAOpenHapticsManager *> (servant);
  
  _repository_id_CORBAOpenHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:508

void POA_CORBAOpenHapticsManager::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_CORBAOpenHapticsManager * const impl =
    static_cast<POA_CORBAOpenHapticsManager *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/upcall_command_ss.cpp:136

class _get_component_CORBAOpenHapticsManager_Upcall_Command
  : public TAO::Upcall_Command
{
public:
  inline _get_component_CORBAOpenHapticsManager_Upcall_Command (
    POA_CORBAOpenHapticsManager * servant,
    TAO_Operation_Details const * operation_details,
    TAO::Argument * const args[])
    : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
  {
  }
  
  virtual void execute (void)
  {
    TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
      TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
        this->operation_details_,
        this->args_);
    
    retval =
      this->servant_-> _get_component ();
  }

private:
  POA_CORBAOpenHapticsManager * const servant_;
  TAO_Operation_Details const * const operation_details_;
  TAO::Argument * const * const args_;
};

void POA_CORBAOpenHapticsManager::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBAOpenHapticsManager * const impl =
    static_cast<POA_CORBAOpenHapticsManager *> (servant);
  
  _get_component_CORBAOpenHapticsManager_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBAOpenHapticsManager::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAHapticsManager:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:CORBAOpenHapticsManager:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBAOpenHapticsManager::_interface_repository_id (void) const
{
  return "IDL:CORBAOpenHapticsManager:1.0";
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:902

void POA_CORBAOpenHapticsManager::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ss.cpp:852

CORBAOpenHapticsManager *
POA_CORBAOpenHapticsManager::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBAOpenHapticsManager STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_function_pointer
      );
}

#endif /* ifndef */

