// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:135

#ifndef _TAO_IDL_HAPTICSC_H_
#define _TAO_IDL_HAPTICSC_H_

#include /**/ "ace/pre.h"


#include /**/ "ace/config-all.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include /**/ "haptics_common_export.h"
#include "tao/ORB.h"
#include "tao/SystemException.h"
#include "tao/Basic_Types.h"
#include "tao/ORB_Constants.h"
#include "tao/Object.h"
#include "tao/Sequence_T.h"
#include "tao/Objref_VarOut_T.h"
#include "tao/Seq_Var_T.h"
#include "tao/Seq_Out_T.h"
#include "tao/VarOut_T.h"
#include "tao/Array_VarOut_T.h"
#include /**/ "tao/Versioned_Namespace.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO HAPTICS_COMMON_Export

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_root/root_ch.cpp:62
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  class Collocation_Proxy_Broker;
  template<typename T> class Narrow_Utils;
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_array/array_ch.cpp:62

#if !defined (_POSITION_CH_)
#define _POSITION_CH_

typedef ::CORBA::Double Position[3];
typedef ::CORBA::Double Position_slice;
struct Position_tag {};


typedef
  TAO_FixedArray_Var_T<
      Position,
      Position_slice,
      Position_tag
    >
  Position_var;

typedef
  Position
  Position_out;

typedef
  TAO_Array_Forany_T<
      Position,
      Position_slice,
      Position_tag
    >
  Position_forany;

TAO_EXPORT_MACRO Position_slice *
Position_alloc (void);

TAO_EXPORT_MACRO void
Position_free (
    Position_slice *_tao_slice 
  );

TAO_EXPORT_MACRO Position_slice *
Position_dup (
    const Position_slice *_tao_slice
  );

TAO_EXPORT_MACRO void
Position_copy (
    Position_slice *_tao_to,
    const Position_slice *_tao_from
  );


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_array/array_ch.cpp:62

#if !defined (_ORIENTATION_CH_)
#define _ORIENTATION_CH_

typedef ::CORBA::Double Orientation[3][3];
typedef ::CORBA::Double Orientation_slice[3];
struct Orientation_tag {};


typedef
  TAO_FixedArray_Var_T<
      Orientation,
      Orientation_slice,
      Orientation_tag
    >
  Orientation_var;

typedef
  Orientation
  Orientation_out;

typedef
  TAO_Array_Forany_T<
      Orientation,
      Orientation_slice,
      Orientation_tag
    >
  Orientation_forany;

TAO_EXPORT_MACRO Orientation_slice *
Orientation_alloc (void);

TAO_EXPORT_MACRO void
Orientation_free (
    Orientation_slice *_tao_slice 
  );

TAO_EXPORT_MACRO Orientation_slice *
Orientation_dup (
    const Orientation_slice *_tao_slice
  );

TAO_EXPORT_MACRO void
Orientation_copy (
    Orientation_slice *_tao_to,
    const Orientation_slice *_tao_from
  );


#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:107

#if !defined (_DOUBLEVECTOR_CH_)
#define _DOUBLEVECTOR_CH_

class DoubleVector;

typedef
  TAO_FixedSeq_Var_T<
      DoubleVector
    >
  DoubleVector_var;

typedef
  TAO_Seq_Out_T<
      DoubleVector
    >
  DoubleVector_out;

class HAPTICS_COMMON_Export DoubleVector
  : public
      TAO::unbounded_value_sequence<
          ::CORBA::Double
        >
{
public:
  DoubleVector (void);
  DoubleVector ( ::CORBA::ULong max);
  DoubleVector (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Double* buffer, 
      ::CORBA::Boolean release = false
    );
  DoubleVector (const DoubleVector &);
  virtual ~DoubleVector (void);
  
  typedef DoubleVector_var _var_type;
  typedef DoubleVector_out _out_type;
  
  
};

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/sequence_ch.cpp:107

#if !defined (_DOUBLEMATRIX_CH_)
#define _DOUBLEMATRIX_CH_

class DoubleMatrix;

typedef
  TAO_FixedSeq_Var_T<
      DoubleMatrix
    >
  DoubleMatrix_var;

typedef
  TAO_Seq_Out_T<
      DoubleMatrix
    >
  DoubleMatrix_out;

class HAPTICS_COMMON_Export DoubleMatrix
  : public
      TAO::unbounded_value_sequence<
          ::CORBA::Double
        >
{
public:
  DoubleMatrix (void);
  DoubleMatrix ( ::CORBA::ULong max);
  DoubleMatrix (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Double* buffer, 
      ::CORBA::Boolean release = false
    );
  DoubleMatrix (const DoubleMatrix &);
  virtual ~DoubleMatrix (void);
  
  typedef DoubleMatrix_var _var_type;
  typedef DoubleMatrix_out _out_type;
  
  
};

#endif /* end #if !defined */

// TAO_IDL - Generated from
// .\be\be_type.cpp:269

struct CORBAHapticConfiguration;

typedef
  TAO_Fixed_Var_T<
      CORBAHapticConfiguration
    >
  CORBAHapticConfiguration_var;

typedef
  CORBAHapticConfiguration &
  CORBAHapticConfiguration_out;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:57

struct HAPTICS_COMMON_Export CORBAHapticConfiguration
{
  typedef CORBAHapticConfiguration_var _var_type;
  typedef CORBAHapticConfiguration_out _out_type;
  
  
  Position pos;
  Orientation orient;
  ::CORBA::UShort buttonState;
};

// TAO_IDL - Generated from
// .\be\be_type.cpp:269

struct CORBAGiPSiLowOrderLinearHapticModel;

typedef
  TAO_Var_Var_T<
      CORBAGiPSiLowOrderLinearHapticModel
    >
  CORBAGiPSiLowOrderLinearHapticModel_var;

typedef
  TAO_Out_T<
      CORBAGiPSiLowOrderLinearHapticModel
    >
  CORBAGiPSiLowOrderLinearHapticModel_out;

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/structure_ch.cpp:57

struct HAPTICS_COMMON_Export CORBAGiPSiLowOrderLinearHapticModel
{
  typedef CORBAGiPSiLowOrderLinearHapticModel_var _var_type;
  typedef CORBAGiPSiLowOrderLinearHapticModel_out _out_type;
  
  
  ::CORBA::Short n;
  ::CORBA::Short m;
  ::CORBA::Short k;
  DoubleMatrix A11;
  DoubleMatrix A12;
  DoubleMatrix B1;
  DoubleMatrix C11;
  DoubleMatrix C12;
  DoubleMatrix D;
  DoubleVector f_0;
  DoubleVector zdot_0;
  DoubleVector normal;
};

// TAO_IDL - Generated from
// .\be\be_interface.cpp:638

#if !defined (_CORBAHAPTICINTERFACE__VAR_OUT_CH_)
#define _CORBAHAPTICINTERFACE__VAR_OUT_CH_

class CORBAHapticInterface;
typedef CORBAHapticInterface *CORBAHapticInterface_ptr;

typedef
  TAO_Objref_Var_T<
      CORBAHapticInterface
    >
  CORBAHapticInterface_var;

typedef
  TAO_Objref_Out_T<
      CORBAHapticInterface
    >
  CORBAHapticInterface_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:54

#if !defined (_CORBAHAPTICINTERFACE_CH_)
#define _CORBAHAPTICINTERFACE_CH_

class HAPTICS_COMMON_Export CORBAHapticInterface
  : public virtual ::CORBA::Object
{
public:
  friend class TAO::Narrow_Utils<CORBAHapticInterface>;
  typedef CORBAHapticInterface_ptr _ptr_type;
  typedef CORBAHapticInterface_var _var_type;
  typedef CORBAHapticInterface_out _out_type;
  
  // The static operations.
  static CORBAHapticInterface_ptr _duplicate (CORBAHapticInterface_ptr obj);
  
  static void _tao_release (CORBAHapticInterface_ptr obj);
  
  static CORBAHapticInterface_ptr _narrow (::CORBA::Object_ptr obj);
  static CORBAHapticInterface_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static CORBAHapticInterface_ptr _nil (void)
  {
    return static_cast<CORBAHapticInterface_ptr> (0);
  }
  
  
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Boolean Enable (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Boolean Disable (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Boolean Terminate (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short ReturnHapticInterfaceIdentifier (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Boolean IsInitialized (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Boolean IsEnabled (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Double ReportUpdateRate (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Double ReportSamplingTime (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBAHapticConfiguration ReadConfiguration (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short UseHapticModel (
      const ::CORBAGiPSiLowOrderLinearHapticModel & model);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:216
  
  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
private:
  TAO::Collocation_Proxy_Broker *the_TAO_CORBAHapticInterface_Proxy_Broker_;

protected:
  // Concrete interface only.
  CORBAHapticInterface (void);
  
  // These methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode.
  virtual void CORBAHapticInterface_setup_collocation (void);
  
  // Concrete non-local interface only.
  CORBAHapticInterface (
      IOP::IOR *ior,
      TAO_ORB_Core *orb_core = 0);
  
  // Non-local interface only.
  CORBAHapticInterface (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);
  
  virtual ~CORBAHapticInterface (void);

private:
  // Private and unimplemented for concrete interfaces.
  CORBAHapticInterface (const CORBAHapticInterface &);
  
  void operator= (const CORBAHapticInterface &);
};

#endif /* end #if !defined */

// TAO_IDL - Generated from
// .\be\be_interface.cpp:638

#if !defined (_CORBAPHANTOMHAPTICINTERFACE__VAR_OUT_CH_)
#define _CORBAPHANTOMHAPTICINTERFACE__VAR_OUT_CH_

class CORBAPhantomHapticInterface;
typedef CORBAPhantomHapticInterface *CORBAPhantomHapticInterface_ptr;

typedef
  TAO_Objref_Var_T<
      CORBAPhantomHapticInterface
    >
  CORBAPhantomHapticInterface_var;

typedef
  TAO_Objref_Out_T<
      CORBAPhantomHapticInterface
    >
  CORBAPhantomHapticInterface_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:54

#if !defined (_CORBAPHANTOMHAPTICINTERFACE_CH_)
#define _CORBAPHANTOMHAPTICINTERFACE_CH_

class HAPTICS_COMMON_Export CORBAPhantomHapticInterface
  : public virtual ::CORBAHapticInterface
{
public:
  friend class TAO::Narrow_Utils<CORBAPhantomHapticInterface>;
  typedef CORBAPhantomHapticInterface_ptr _ptr_type;
  typedef CORBAPhantomHapticInterface_var _var_type;
  typedef CORBAPhantomHapticInterface_out _out_type;
  
  // The static operations.
  static CORBAPhantomHapticInterface_ptr _duplicate (CORBAPhantomHapticInterface_ptr obj);
  
  static void _tao_release (CORBAPhantomHapticInterface_ptr obj);
  
  static CORBAPhantomHapticInterface_ptr _narrow (::CORBA::Object_ptr obj);
  static CORBAPhantomHapticInterface_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static CORBAPhantomHapticInterface_ptr _nil (void)
  {
    return static_cast<CORBAPhantomHapticInterface_ptr> (0);
  }
  
  
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short SetHandle (
      ::CORBA::Short handler);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short switchModel (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short ReturnHandle (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:216
  
  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
private:
  TAO::Collocation_Proxy_Broker *the_TAO_CORBAPhantomHapticInterface_Proxy_Broker_;

protected:
  // Concrete interface only.
  CORBAPhantomHapticInterface (void);
  
  // These methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode.
  virtual void CORBAPhantomHapticInterface_setup_collocation (void);
  
  // Concrete non-local interface only.
  CORBAPhantomHapticInterface (
      IOP::IOR *ior,
      TAO_ORB_Core *orb_core = 0);
  
  // Non-local interface only.
  CORBAPhantomHapticInterface (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);
  
  virtual ~CORBAPhantomHapticInterface (void);

private:
  // Private and unimplemented for concrete interfaces.
  CORBAPhantomHapticInterface (const CORBAPhantomHapticInterface &);
  
  void operator= (const CORBAPhantomHapticInterface &);
};

#endif /* end #if !defined */

// TAO_IDL - Generated from
// .\be\be_interface.cpp:638

#if !defined (_CORBAMOUSEHAPTICINTERFACE__VAR_OUT_CH_)
#define _CORBAMOUSEHAPTICINTERFACE__VAR_OUT_CH_

class CORBAMouseHapticInterface;
typedef CORBAMouseHapticInterface *CORBAMouseHapticInterface_ptr;

typedef
  TAO_Objref_Var_T<
      CORBAMouseHapticInterface
    >
  CORBAMouseHapticInterface_var;

typedef
  TAO_Objref_Out_T<
      CORBAMouseHapticInterface
    >
  CORBAMouseHapticInterface_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:54

#if !defined (_CORBAMOUSEHAPTICINTERFACE_CH_)
#define _CORBAMOUSEHAPTICINTERFACE_CH_

class HAPTICS_COMMON_Export CORBAMouseHapticInterface
  : public virtual ::CORBAHapticInterface
{
public:
  friend class TAO::Narrow_Utils<CORBAMouseHapticInterface>;
  typedef CORBAMouseHapticInterface_ptr _ptr_type;
  typedef CORBAMouseHapticInterface_var _var_type;
  typedef CORBAMouseHapticInterface_out _out_type;
  
  // The static operations.
  static CORBAMouseHapticInterface_ptr _duplicate (CORBAMouseHapticInterface_ptr obj);
  
  static void _tao_release (CORBAMouseHapticInterface_ptr obj);
  
  static CORBAMouseHapticInterface_ptr _narrow (::CORBA::Object_ptr obj);
  static CORBAMouseHapticInterface_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static CORBAMouseHapticInterface_ptr _nil (void)
  {
    return static_cast<CORBAMouseHapticInterface_ptr> (0);
  }
  
  
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:216
  
  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
private:
  TAO::Collocation_Proxy_Broker *the_TAO_CORBAMouseHapticInterface_Proxy_Broker_;

protected:
  // Concrete interface only.
  CORBAMouseHapticInterface (void);
  
  // These methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode.
  virtual void CORBAMouseHapticInterface_setup_collocation (void);
  
  // Concrete non-local interface only.
  CORBAMouseHapticInterface (
      IOP::IOR *ior,
      TAO_ORB_Core *orb_core = 0);
  
  // Non-local interface only.
  CORBAMouseHapticInterface (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);
  
  virtual ~CORBAMouseHapticInterface (void);

private:
  // Private and unimplemented for concrete interfaces.
  CORBAMouseHapticInterface (const CORBAMouseHapticInterface &);
  
  void operator= (const CORBAMouseHapticInterface &);
};

#endif /* end #if !defined */

// TAO_IDL - Generated from
// .\be\be_interface.cpp:638

#if !defined (_CORBAHAPTICSMANAGER__VAR_OUT_CH_)
#define _CORBAHAPTICSMANAGER__VAR_OUT_CH_

class CORBAHapticsManager;
typedef CORBAHapticsManager *CORBAHapticsManager_ptr;

typedef
  TAO_Objref_Var_T<
      CORBAHapticsManager
    >
  CORBAHapticsManager_var;

typedef
  TAO_Objref_Out_T<
      CORBAHapticsManager
    >
  CORBAHapticsManager_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:54

#if !defined (_CORBAHAPTICSMANAGER_CH_)
#define _CORBAHAPTICSMANAGER_CH_

class HAPTICS_COMMON_Export CORBAHapticsManager
  : public virtual ::CORBA::Object
{
public:
  friend class TAO::Narrow_Utils<CORBAHapticsManager>;
  typedef CORBAHapticsManager_ptr _ptr_type;
  typedef CORBAHapticsManager_var _var_type;
  typedef CORBAHapticsManager_out _out_type;
  
  // The static operations.
  static CORBAHapticsManager_ptr _duplicate (CORBAHapticsManager_ptr obj);
  
  static void _tao_release (CORBAHapticsManager_ptr obj);
  
  static CORBAHapticsManager_ptr _narrow (::CORBA::Object_ptr obj);
  static CORBAHapticsManager_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static CORBAHapticsManager_ptr _nil (void)
  {
    return static_cast<CORBAHapticsManager_ptr> (0);
  }
  
  
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short StartHapticsThread (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short EndHapticsThread (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Boolean isHapticsThreadRunning (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_operation/operation_ch.cpp:46
  
  virtual ::CORBA::Short GetNumHapticInterfaces (
      void);
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:216
  
  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
private:
  TAO::Collocation_Proxy_Broker *the_TAO_CORBAHapticsManager_Proxy_Broker_;

protected:
  // Concrete interface only.
  CORBAHapticsManager (void);
  
  // These methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode.
  virtual void CORBAHapticsManager_setup_collocation (void);
  
  // Concrete non-local interface only.
  CORBAHapticsManager (
      IOP::IOR *ior,
      TAO_ORB_Core *orb_core = 0);
  
  // Non-local interface only.
  CORBAHapticsManager (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);
  
  virtual ~CORBAHapticsManager (void);

private:
  // Private and unimplemented for concrete interfaces.
  CORBAHapticsManager (const CORBAHapticsManager &);
  
  void operator= (const CORBAHapticsManager &);
};

#endif /* end #if !defined */

// TAO_IDL - Generated from
// .\be\be_interface.cpp:638

#if !defined (_CORBAOPENHAPTICSMANAGER__VAR_OUT_CH_)
#define _CORBAOPENHAPTICSMANAGER__VAR_OUT_CH_

class CORBAOpenHapticsManager;
typedef CORBAOpenHapticsManager *CORBAOpenHapticsManager_ptr;

typedef
  TAO_Objref_Var_T<
      CORBAOpenHapticsManager
    >
  CORBAOpenHapticsManager_var;

typedef
  TAO_Objref_Out_T<
      CORBAOpenHapticsManager
    >
  CORBAOpenHapticsManager_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:54

#if !defined (_CORBAOPENHAPTICSMANAGER_CH_)
#define _CORBAOPENHAPTICSMANAGER_CH_

class HAPTICS_COMMON_Export CORBAOpenHapticsManager
  : public virtual ::CORBAHapticsManager
{
public:
  friend class TAO::Narrow_Utils<CORBAOpenHapticsManager>;
  typedef CORBAOpenHapticsManager_ptr _ptr_type;
  typedef CORBAOpenHapticsManager_var _var_type;
  typedef CORBAOpenHapticsManager_out _out_type;
  
  // The static operations.
  static CORBAOpenHapticsManager_ptr _duplicate (CORBAOpenHapticsManager_ptr obj);
  
  static void _tao_release (CORBAOpenHapticsManager_ptr obj);
  
  static CORBAOpenHapticsManager_ptr _narrow (::CORBA::Object_ptr obj);
  static CORBAOpenHapticsManager_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static CORBAOpenHapticsManager_ptr _nil (void)
  {
    return static_cast<CORBAOpenHapticsManager_ptr> (0);
  }
  
  
  
  // TAO_IDL - Generated from
  // c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/interface_ch.cpp:216
  
  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
private:
  TAO::Collocation_Proxy_Broker *the_TAO_CORBAOpenHapticsManager_Proxy_Broker_;

protected:
  // Concrete interface only.
  CORBAOpenHapticsManager (void);
  
  // These methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode.
  virtual void CORBAOpenHapticsManager_setup_collocation (void);
  
  // Concrete non-local interface only.
  CORBAOpenHapticsManager (
      IOP::IOR *ior,
      TAO_ORB_Core *orb_core = 0);
  
  // Non-local interface only.
  CORBAOpenHapticsManager (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);
  
  virtual ~CORBAOpenHapticsManager (void);

private:
  // Private and unimplemented for concrete interfaces.
  CORBAOpenHapticsManager (const CORBAOpenHapticsManager &);
  
  void operator= (const CORBAOpenHapticsManager &);
};

#endif /* end #if !defined */

// Proxy Broker Factory function pointer declarations.

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_root/root.cpp:139

extern HAPTICS_COMMON_Export
TAO::Collocation_Proxy_Broker *
(*_TAO_CORBAHapticInterface_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  );

extern HAPTICS_COMMON_Export
TAO::Collocation_Proxy_Broker *
(*_TAO_CORBAPhantomHapticInterface_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  );

extern HAPTICS_COMMON_Export
TAO::Collocation_Proxy_Broker *
(*_TAO_CORBAMouseHapticInterface_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  );

extern HAPTICS_COMMON_Export
TAO::Collocation_Proxy_Broker *
(*_TAO_CORBAHapticsManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  );

extern HAPTICS_COMMON_Export
TAO::Collocation_Proxy_Broker *
(*_TAO_CORBAOpenHapticsManager_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  );

// TAO_IDL - Generated from
// .\be\be_visitor_traits.cpp:64

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{
  template<>
  struct HAPTICS_COMMON_Export Array_Traits<
      Position_forany
    >
  {
    static void free (
        Position_slice * _tao_slice
      );
    static Position_slice * dup (
        const Position_slice * _tao_slice
      );
    static void copy (
        Position_slice * _tao_to,
        const Position_slice * _tao_from
      );
    static Position_slice * alloc (void);
    static void zero (
        Position_slice * _tao_slice
      );
  };
  template<>
  struct HAPTICS_COMMON_Export Array_Traits<
      Orientation_forany
    >
  {
    static void free (
        Orientation_slice * _tao_slice
      );
    static Orientation_slice * dup (
        const Orientation_slice * _tao_slice
      );
    static void copy (
        Orientation_slice * _tao_to,
        const Orientation_slice * _tao_from
      );
    static Orientation_slice * alloc (void);
    static void zero (
        Orientation_slice * _tao_slice
      );
  };

#if !defined (_CORBAHAPTICINTERFACE__TRAITS_)
#define _CORBAHAPTICINTERFACE__TRAITS_
  
  template<>
  struct HAPTICS_COMMON_Export Objref_Traits< ::CORBAHapticInterface>
  {
    static ::CORBAHapticInterface_ptr duplicate (
        ::CORBAHapticInterface_ptr
      );
    static void release (
        ::CORBAHapticInterface_ptr
      );
    static ::CORBAHapticInterface_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CORBAHapticInterface_ptr p,
        TAO_OutputCDR & cdr
      );
  };

#endif /* end #if !defined */

#if !defined (_CORBAPHANTOMHAPTICINTERFACE__TRAITS_)
#define _CORBAPHANTOMHAPTICINTERFACE__TRAITS_
  
  template<>
  struct HAPTICS_COMMON_Export Objref_Traits< ::CORBAPhantomHapticInterface>
  {
    static ::CORBAPhantomHapticInterface_ptr duplicate (
        ::CORBAPhantomHapticInterface_ptr
      );
    static void release (
        ::CORBAPhantomHapticInterface_ptr
      );
    static ::CORBAPhantomHapticInterface_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CORBAPhantomHapticInterface_ptr p,
        TAO_OutputCDR & cdr
      );
  };

#endif /* end #if !defined */

#if !defined (_CORBAMOUSEHAPTICINTERFACE__TRAITS_)
#define _CORBAMOUSEHAPTICINTERFACE__TRAITS_
  
  template<>
  struct HAPTICS_COMMON_Export Objref_Traits< ::CORBAMouseHapticInterface>
  {
    static ::CORBAMouseHapticInterface_ptr duplicate (
        ::CORBAMouseHapticInterface_ptr
      );
    static void release (
        ::CORBAMouseHapticInterface_ptr
      );
    static ::CORBAMouseHapticInterface_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CORBAMouseHapticInterface_ptr p,
        TAO_OutputCDR & cdr
      );
  };

#endif /* end #if !defined */

#if !defined (_CORBAHAPTICSMANAGER__TRAITS_)
#define _CORBAHAPTICSMANAGER__TRAITS_
  
  template<>
  struct HAPTICS_COMMON_Export Objref_Traits< ::CORBAHapticsManager>
  {
    static ::CORBAHapticsManager_ptr duplicate (
        ::CORBAHapticsManager_ptr
      );
    static void release (
        ::CORBAHapticsManager_ptr
      );
    static ::CORBAHapticsManager_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CORBAHapticsManager_ptr p,
        TAO_OutputCDR & cdr
      );
  };

#endif /* end #if !defined */

#if !defined (_CORBAOPENHAPTICSMANAGER__TRAITS_)
#define _CORBAOPENHAPTICSMANAGER__TRAITS_
  
  template<>
  struct HAPTICS_COMMON_Export Objref_Traits< ::CORBAOpenHapticsManager>
  {
    static ::CORBAOpenHapticsManager_ptr duplicate (
        ::CORBAOpenHapticsManager_ptr
      );
    static void release (
        ::CORBAOpenHapticsManager_ptr
      );
    static ::CORBAOpenHapticsManager_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::CORBAOpenHapticsManager_ptr p,
        TAO_OutputCDR & cdr
      );
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_array/cdr_op_ch.cpp:116


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::Position_forany &_tao_array);
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, ::Position_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_array/cdr_op_ch.cpp:116


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::Orientation_forany &_tao_array);
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, ::Orientation_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:71

#if !defined _TAO_CDR_OP_DoubleVector_H_
#define _TAO_CDR_OP_DoubleVector_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DoubleVector &_tao_sequence
  );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DoubleVector &_tao_sequence
  );
TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_DoubleVector_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_sequence/cdr_op_ch.cpp:71

#if !defined _TAO_CDR_OP_DoubleMatrix_H_
#define _TAO_CDR_OP_DoubleMatrix_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DoubleMatrix &_tao_sequence
  );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DoubleMatrix &_tao_sequence
  );
TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_DoubleMatrix_H_ */

// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAHapticConfiguration &);
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAHapticConfiguration &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_structure/cdr_op_ch.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAGiPSiLowOrderLinearHapticModel &);
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAGiPSiLowOrderLinearHapticModel &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:55

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAHapticInterface_ptr );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAHapticInterface_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:55

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAPhantomHapticInterface_ptr );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAPhantomHapticInterface_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:55

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAMouseHapticInterface_ptr );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAMouseHapticInterface_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:55

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAHapticsManager_ptr );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAHapticsManager_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// c:\ace_wrappers\tao\tao_idl\be\be_visitor_interface/cdr_op_ch.cpp:55

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

HAPTICS_COMMON_Export ::CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBAOpenHapticsManager_ptr );
HAPTICS_COMMON_Export ::CORBA::Boolean operator>> (TAO_InputCDR &, CORBAOpenHapticsManager_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// .\be\be_codegen.cpp:1219
#if defined (__ACE_INLINE__)
#include "HapticsC.inl"
#endif /* defined INLINE */

#include /**/ "ace/post.h"

#endif /* ifndef */


